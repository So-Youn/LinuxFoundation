# System Monitoring

**Process and Load Monitoring Utilities**

## /proc

* **/proc** filesystem은 process 및 system을 모니터링하는데 도움을 준다.
  * 커널 데이터 구조에 대한 인터페이스로, /proc에는 PID로 명명된 활성 프로세스에 대한 하위 디렉토리가 있다.
  * `/proc/self` 는 현재 실행중인 프로세스

| UTILITY      | PURPOSE                                                  | PACKAGE                    |
| :----------- | :------------------------------------------------------- | :------------------------- |
| **top**      | Process activity, dynamically updated                    | **procps**                 |
| **uptime**   | How long the system is running and the average load      | **procps**                 |
| **ps**       | Detailed information about processes                     | **procps**                 |
| **pstree**   | A tree of processes and their connections                | **psmisc** (or **pstree**) |
| **mpstat**   | Multiple processor usage                                 | **sysstat**                |
| **iostat**   | CPU utilization and I/O statistics                       | **sysstat**                |
| **sar**      | Display and collect information about system activity    | **sysstat**                |
| **numastat** | Information about NUMA (Non-Uniform Memory Architecture) | **numactl**                |
| **strace**   | Information about all system calls a process makes       | **strace**                 |

* `ps` : 현재 실행중인 프로세스 목록과 상태

  * `ps -elf` `ps aux`

  * 출력 순서 바꾸기

    ```shell
    [root@bef06f544a92 /]# ps -o pid,pri,ni,cmd
      PID PRI  NI CMD
        1  19   0 bash
       16  19   0 ps -o pid,pri,ni,cmd
    ```

  * 실습

    > dd를 사용해서 /dev/urandom에서 읽은 background process를 /dev/null에 쓰기

    ```shell
    [root@bef06f544a92 /]# dd if=/dev/urandom of=/dev/null &
    [1] 40
    [root@bef06f544a92 /]# ps -C dd -o pid,cmd,stat
      PID CMD                         STAT
       40 /usr/bin/coreutils --coreut RN
    ```

    > fg 사용해서 프로세스 가져온뒤 중지시키기

    ```shell
    [root@bef06f544a92 /]# fg
    dd if=/dev/urandom of=/dev/null
    ^Z
    [1]+  Stopped                 dd if=/dev/urandom of=/dev/null
    [root@bef06f544a92 /]# ps -C dd -o pid,cmd,stat
    '  PID CMD                         STAT
       40 /usr/bin/coreutils --coreut TN
    [root@bef06f544a92 /]# jobs
    [1]+  Stopped                 dd if=/dev/urandom of=/dev/null
    [root@bef06f544a92 /]# 
    ```

    

  

* `top` : cpu 사용이 가장 높은 프로세스 표시

```shell
[root@eef676fd512f yum.repos.d]# pstree
bash─┬─pstree
     └─top
[root@eef676fd512f yum.repos.d]# mpstat
Linux 5.10.47-linuxkit (eef676fd512f) 	04/16/2022 	_aarch64_	(4 CPU)

05:14:21 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
05:14:21 PM  all    0.48    0.00    0.69    0.04    0.00    0.11    0.00    0.00    0.00   98.68
```

* **iostat** : 시스템에서 I/O device activity(디스크 입출력에 대한 통계)를 모니터링해주는 tool
  * `-x` : detailed report
  * `utilization percentage`가 100에 도달하면 시스템은 포화되거나 I/O bound된다.

```shell
[root@eef676fd512f ~]# iostat
Linux 5.10.47-linuxkit (eef676fd512f) 	04/16/2022 	_aarch64_	(4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.48    0.00    0.79    0.04    0.00   98.69

Device             tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda              16.45       215.37       280.71     536611     699388
$ iostat -m /dev/sda /dev/sdb 2 200
```

* **iotop** : 현재 I/O의 사용 및 updates에 대한 테이블

  * PRIO에서 `be(best effort)` 와 `rt(real time)`

  ```shell
  $ sudo iotop
  ```

  ![Screenshot of the sudo iotop output command](images/0c8ycbojogvz-iotop-20220508131223538.png)

* **ionice** : 주어진 프로세스에서 I/O 스케줄링 클래스와 우선순위에 대해 확인 및 설정할 수 있다.

  * `-c` : I/O 스케줄링 클래스 설정

  | SCHEDULING CLASS | -C   | 의미                                                         |
  | :--------------- | :--- | :----------------------------------------------------------- |
  |                  | 0    | Default                                                      |
  | Real Time        | 1    | Get first access to the disk, can starve other processes. The priority defines how big a time slice each process gets. |
  | Best Effort      | 2    | All programs serviced in round-robin fashion, according to priority settings. The Default. |
  | Idle             | 3    | No access to disk I/O unless no other program has asked for it for a defined period. |

  * Real Time과 Best Effort는 우선순위를 정하는 `-n`을 줘야 한다. (0~7, 0 은 가장 높은 우선순위)

  ```shell
  $ ionice -c 2 -n 3 -p 30078
  $ for names in */*.vmdk ; do /bin/cp $names /tmp/junk ; done
  ```

  

**Table: Memory Monitoring Utilities**

* 메모리 parameter를 바꾸는 것은 I/O perfomance에 큰 영향이 있다. 

| UTILITY    | PURPOSE                                                      | PACKAGE    |
| :--------- | :----------------------------------------------------------- | :--------- |
| **free**   | Brief summary of memory usage                                | **procps** |
| **vmstat** | Detailed virtual memory statistics and block I/O, dynamically updated | **procps** |
| **pmap**   | Process memory map                                           | **procps** |

* `/proc/meminfo` : memory를 얼마나 사용하고 있는지에 대한 정보 보여준다.

```shell
[root@6571292a6101 /]# cat /proc/meminfo 
MemTotal:        2036540 kB
MemFree:          205424 kB
MemAvailable:    1063684 kB
Buffers:           75172 kB # 일시적인 block을 위해 사용된 메모리
Cached:          1133228 kB # file I/O
SwapCached:          728 kB
Active:           416156 kB
Inactive:        1206816 kB
Active(anon):      71852 kB # anonymous
Inactive(anon):   720296 kB
Active(file):     344304 kB
Inactive(file):   486520 kB
Unevictable:           0 kB
Mlocked:               0 kB
SwapTotal:       1048572 kB
SwapFree:        1039020 kB
....
```

* `/proc/sys/vm` : Virtual Memory System을 컨트롤할 수 있는 knob

  ```shell
  [root@6571292a6101 vm]# ls /proc/sys/vm/
  admin_reserve_kbytes	     dirty_background_ratio	drop_caches	      max_map_count	       oom_dump_tasks		 page_lock_unfairness	   user_reserve_kbytes
  block_dump		     dirty_bytes		extfrag_threshold     min_free_kbytes	       oom_kill_allocating_task  panic_on_oom		   vfs_cache_pressure
  compact_memory		     dirty_expire_centisecs	hugetlb_shm_group     mmap_min_addr	       overcommit_kbytes	 percpu_pagelist_fraction  watermark_boost_factor
  compact_unevictable_allowed  dirty_ratio		laptop_mode	      mmap_rnd_bits	       overcommit_memory	 stat_interval		   watermark_scale_factor
  compaction_proactiveness     dirty_writeback_centisecs	legacy_va_layout      nr_hugepages	       overcommit_ratio		 stat_refresh
  dirty_background_bytes	     dirtytime_expire_seconds	lowmem_reserve_ratio  nr_overcommit_hugepages  page-cluster		 swappiness
  ```

**Table: I/O Monitoring Utilities**

| UTILITY    | PURPOSE                                                      | PACKAGE     |
| :--------- | :----------------------------------------------------------- | :---------- |
| **iostat** | CPU utilization and I/O statistics                           | **sysstat** |
| **sar**    | Display and collect information about system activity        | **sysstat** |
| **vmstat** | Detailed virtual memory statistics and block I/O, dynamically updated | **procps**  |

* `sar` : system activity나 performance data를 수집하는 목적.
  * `/var/log/sa` 에 data가 저장된다.
    * `/etc/cron.d/sysstat` 에 cron job 등록되어 있음
  * `$ sar [option] [interval] [count]`

```shell
[root@eef676fd512f yum.repos.d]# sar 3 3
Linux 5.10.47-linuxkit (eef676fd512f) 	04/16/2022 	_aarch64_	(4 CPU)

05:17:47 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
05:17:50 PM     all      0.00      0.00      0.25      0.00      0.00     99.75
05:17:53 PM     all      0.00      0.00      0.25      0.00      0.00     99.75
05:17:56 PM     all      0.33      0.00      0.25      0.08      0.00     99.33
Average:        all      0.11      0.00      0.25      0.03      0.00     99.61
```

* `vmstat` : memory, paging, I/O,processor에 대한 정보를 보여주는 tool.

  ```shell
  [root@eef676fd512f yum.repos.d]# vmstat
  procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
   r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
   2  0   3616 227616  60796 1249816    0    0    57    74  252  398  0  1 99  0  0
  ```

  

**Table: Network Monitoring Utilities**

| UTILITY       | PURPOSE                                          | PACKAGE       |
| :------------ | :----------------------------------------------- | :------------ |
| **netstat**   | Detailed networking statistics                   | **netstat**   |
| **iptraf**    | Gather information on network interfaces         | **iptraf**    |
| **tcpdump**   | Detailed analysis of network packets and traffic | **tcpdump**   |
| **wireshark** | Detailed network traffic analysis                | **wireshark** |

## log

* 시스템 로그 확인 법
  * `/var/log/messages`
  * `dmesg -w`
* `boot.log` : 시스템 boot message
* `dmes` : boot된 후에 저장된 kernel message
*  `secure`

# OOM Killker

> **Out of Memory Killer**
>
> Linux는 메모리 `overcommit` 메커니즘이 적용되어 있어 실제 메모리 이상의 공간이 확보 가능하다. 이는 실제 OS 내부적으로 프로세스를 마음대로 Kill 해버린다.
>
> :point_right: `OOM killer`는 시스템이 실제 메모리와 가상메모리공간(swap)을 다 사용해, 필요한 메모리 공간을 새로 확보할 수 없는 경우 프로세스를 종료시켜 여유 메모리를 확보하는 것이다.

* /proc/sys/vm/overcommit_memory 
  * 0 (default) : overcommit을 허용하지만, root user에게 일반 사용자보다 좀 더 메모리 할당을 할 수 있도록 한다.
  * 1 : 모든 메모리 requests를 overcommit하도록 허락한다.
  * 2 : overcommission을 끈다. 메모리가 부족할 경우 메모리 확보시 에러 발생

* Invoking the OOM Killer

  ```markdown
  1. sudo /sbin/swapoff -a
  2. sudo /sbin/swapon -a
  3. stress-ng -m 12 -t 10s
  ```



# bonnie++

> bonnie++은 drive와 filesystem의 성능을 평가할 수 있는 program

```shell
$ bonnie++ --help
$ sudo bonnie++ -n 0 -u 0 -r 100 -f -b -d /mnt

$ bon_csv2html < bonnie++.out > bonnie++.html
$ bon_csv2txt < bonnie++.out > bonnie++.txt
```



