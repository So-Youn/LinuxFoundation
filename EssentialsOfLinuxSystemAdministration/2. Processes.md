# Process

> 실행중인 program의 instance
>
> * **pid** (프로세스 ID), **ppid** (상위 프로세스 ID) 및 **pgid** (프로세스 그룹 ID)

* 프로세스는 scheduling에 의해 control되며, 오직 kernel이 process를 선점할 수 있는 권리가 있다.
* 모든 프로세스는 다음과 같은 속성이 있다.
  * The program being executed
  * Context (state)
  * Permissions
  * Associated resources.
* **setuid** :
  * 모든 프로세스는 call / own에 사용자에 따라 권한이 있다.
  * `s` 실행 비트로 표시된 프로그램은 실제 사용자 ID와 다른 유효 사용자 ID를 갖는다.
  * `setuid`가 아닌 프로그램은 시작하는 사용자의 권한으로 실행된다.

* 프로세스가 시작되면 다른 프로세스로부터 보호하기 위해 (보안/안정성) 자신만의 user space에 isolated된다. 
* HW는 kernel에 의해 manage되며, 프로세스는 HW에 간접적으로 접근하기 위해 system call을 사용한다.

## ulimit

>  **ulimit**은 shell에서 실행되는 프로세스와 관련된 여러 resource limit을 reset하거나 display해주는 bash command

```shell
[root@localhost proc]# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 3755
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 3755
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

```bash
$ cat /etc/security/limits.conf 
$ help ulimit
```



- **Hard**
  The maximum value, set only by the root user, that a user can raise the resource limit to.

  ```shell
  [root@localhost proc]# ulimit -H -n
  4096
  ```

- **Soft**
  The current limiting value, which a user can modify, but cannot exceed the hard limit.

  ```shell
  [root@localhost proc]# ulimit -S -n
  1024
  ```

- particular limit 설정하기

  ```shell
  $ ulimit [options] [limit]
  
  # 최대 file descriptors 1600까지 증가시키기
  [root@localhost proc]# ulimit -n 1600
  ```

- 모든 user에게 적용시키려면 **/etc/security/limits.conf** 파일 수정하기.

### Creating process

> linux system은 항상 새로운 process를 만들고 있는데, 이를 **forking**이라고 부른다. 
>
> 새로운 child process가 시작되는 동안, original parent process가 running 상태로 유지된다.
>
> **exec**은 부모 process를 종료시키고 child process가 부모의 process ID 를 상속한다.

*cf. Unix에서는 spawn을 사용한다.*

## Process states

| status                        |                                                              |
| ----------------------------- | ------------------------------------------------------------ |
| Running                       | - CPU나 CPU에서 실행중 / run queue에서 새로운 time slice를 기다리고 있는 상태<br />- 스케줄러가 CPU가 점유할 가치가 있다고 판단하거나, 다른 CPU가 idle 상태가 되고 스케줄러가 프로세스를 해당 CPU로 migration할 때 running 상태가 된다. |
| Sleeping (i.e. Waiting)       | - request가 완료될 때까지 더이상 진전될 수 없을 때 request(보통 I/O)를 기다림<br />- request가 완료됐을 때 kernel이 process를 깨워서 run queue에 넣는다. |
| Stopped                       | 프로세스가 중단됐을 때.                                      |
| Zombie (=**defunct process**) | 실행이 끝난 후에도 프로세스에서 제거되지 않은 프로세스, 일명 버그. |

### System V IPC

> Inter Process Communication(IPC), 공유 메모리, 세마포어, message Queues에 대한 정보 확인

* IPC 확인

```shell
$ ipcs -q
```

* 공유 메모리 / 세마포어 확인

```shell
$ ipcs -m
$ ipcs -s
```



```shell
$ ipcs
# process에 대한 더 많은 정보
$ ipcs -p
```



## Demon

> **Daemon** 은 시스템 user에게 특정 서비스를 제공하는 background process.
>
> *ex. xinetd, httpd, vsftpd*
>
> * 보통 데몬은 booting 시에 시작되며, 필요할 때만 작동할 수 있어서 효율적이다.
> * 데몬이름을 보통 `d` 로 끝난다. 

## Process Priorities

* `process prioritie`는 `nice` , `renice` command를 통해 제어된다.
  * niceness가 높을 수록, priority가 낮아진다.
  * 범위 : -20(최고 우선순위) ~ +19 (최하위 우선순위)
  * nice값을 지정해주지 않으면 defaul 10

```shell
$ nice -n 5 command [ARGS]
$ nice -5 command [ARGS]
$ nice
$ nice cat &
$ ps -l
```

* `renice` 는 이미 실행중인 프로세스의 nice 값을 변경하고 싶을 때 사용된다. (by superuser)

```shell
$ renice --help
```

* pid 20003의 nice 값을 5로 올리고 싶을 때

```shell
$ renice +5 -p 20003
```

### 실습

```shell
$ ps
$ ps lf
$ renice +5 [pid]
$ ps lf

$ renice -5 [pid] # error
$ sudo renice -5 [pid]

$gnome-system-monitor
```



