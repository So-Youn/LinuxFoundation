# Process

> 실행중인 program의 instance
>
> * **pid** (프로세스 ID), **ppid** (상위 프로세스 ID) 및 **pgid** (프로세스 그룹 ID)

* 프로세스는 scheduling에 의해 control되며, 오직 kernel이 process를 선점할 수 있는 권리가 있다.
* 모든 프로세스는 다음과 같은 속성이 있다.
  * The program being executed
  * Context (state)
  * Permissions
  * Associated resources.
* **setuid** :
  * 모든 프로세스는 call / own에 사용자에 따라 권한이 있다.
  * `s` 실행 비트로 표시된 프로그램은 실제 사용자 ID와 다른 유효 사용자 ID를 갖는다.
  * `setuid`가 아닌 프로그램은 시작하는 사용자의 권한으로 실행된다.

* 프로세스가 시작되면 다른 프로세스로부터 보호하기 위해 (보안/안정성) 자신만의 user space에 isolated된다. 
* HW는 kernel에 의해 manage되며, 프로세스는 HW에 간접적으로 접근하기 위해 system call을 사용한다.

## ulimit

>  **ulimit**은 shell에서 실행되는 프로세스와 관련된 여러 resource limit을 reset하거나 display해주는 bash command

```shell
[root@localhost proc]# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 3755
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 3755
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

- **Hard**
  The maximum value, set only by the root user, that a user can raise the resource limit to.

  ```shell
  [root@localhost proc]# ulimit -H -n
  4096
  ```

- **Soft**
  The current limiting value, which a user can modify, but cannot exceed the hard limit.

  ```shell
  [root@localhost proc]# ulimit -S -n
  1024
  ```

- particular limit 설정하기

  ```shell
  $ ulimit [options] [limit]
  
  # 최대 file descriptors 1600까지 증가시키기
  [root@localhost proc]# ulimit -n 1600
  ```

- 모든 user에게 적용시키려면 **/etc/security/limits.conf** 파일 수정하기.

### Creating process

> linux system은 항상 새로운 process를 만들고 있는데, 이를 **forking**이라고 부른다. 
>
> 새로운 child process가 시작되는 동안, original parent process가 running 상태로 유지된다.
>
> **exec**은 부모 process를 종료시키고 child process가 부모의 process ID 를 상속한다.

*cf. Unix에서는 spawn을 사용한다.*

## Process states

| status                        |                                                              |
| ----------------------------- | ------------------------------------------------------------ |
| Running                       | - CPU나 CPU에서 실행중 / run queue에서 새로운 time slice를 기다리고 있는 상태<br />- 스케줄러가 CPU가 점유할 가치가 있다고 판단하거나, 다른 CPU가 idle 상태가 되고 스케줄러가 프로세스를 해당 CPU로 migration할 때 running 상태가 된다. |
| Sleeping (i.e. Waiting)       | - request가 완료될 때까지 더이상 진전될 수 없을 때 request(보통 I/O)를 기다림<br />- request가 완료됐을 때 kernel이 process를 깨워서 run queue에 넣는다. |
| Stopped                       | 프로세스가 중단됐을 때.                                      |
| Zombie (=**defunct process**) |                                                              |

